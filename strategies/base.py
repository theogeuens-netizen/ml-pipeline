"""
Strategy-as-code base class.

This is the enhanced base class for file-based strategies.
Strategies are Python files that define a `strategy` instance at module level.

Example:
    # strategies/my_strategy.py
    from strategies.base import Strategy, Signal, Side, MarketData

    class MyStrategy(Strategy):
        name = "my_strategy"
        min_probability = 0.90

        def scan(self, markets: list[MarketData]) -> Iterator[Signal]:
            ...

    strategy = MyStrategy()
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Iterator, Optional
import hashlib
import inspect
import logging


class Side(str, Enum):
    """Trading side."""
    BUY = "BUY"
    SELL = "SELL"


@dataclass
class MarketData:
    """
    Market data passed to strategies for scanning.

    Contains current state and metadata from the markets table.
    """
    # Identifiers
    id: int
    condition_id: str
    question: str

    # Token IDs for trading
    yes_token_id: Optional[str]
    no_token_id: Optional[str]

    # Current prices
    price: float  # YES price (0-1)
    best_bid: Optional[float] = None
    best_ask: Optional[float] = None
    spread: Optional[float] = None

    # Time context
    hours_to_close: Optional[float] = None
    end_date: Optional[datetime] = None

    # Volume and liquidity
    volume_24h: Optional[float] = None
    liquidity: Optional[float] = None

    # Orderbook depth (for realistic execution simulation)
    bid_depth_10: Optional[float] = None  # Total bid depth within 10 cents of best bid
    ask_depth_10: Optional[float] = None  # Total ask depth within 10 cents of best ask

    # Categories and metadata
    category: Optional[str] = None
    category_l1: Optional[str] = None  # e.g., CRYPTO, SPORTS, POLITICS
    category_l2: Optional[str] = None  # e.g., Bitcoin, NFL, US Elections
    category_l3: Optional[str] = None  # e.g., Price, Super Bowl, Presidential
    event_id: Optional[str] = None
    event_title: Optional[str] = None

    # Price history (optional, for mean reversion etc.)
    price_history: list[float] = field(default_factory=list)

    # Full snapshot data for audit trail
    snapshot: dict = field(default_factory=dict)


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Contains all information needed for the executor to place an order,
    plus audit trail data for decision replay.
    """
    # What to trade
    token_id: str
    side: Side
    reason: str

    # Market context
    market_id: int
    price_at_signal: float

    # Signal quality metrics
    edge: float = 0.0  # Estimated edge (0-1)
    confidence: float = 0.5  # Confidence in the signal (0-1)

    # Optional sizing hint (framework may override)
    size_usd: Optional[float] = None

    # Order book context
    best_bid: Optional[float] = None
    best_ask: Optional[float] = None

    # Audit trail - filled by framework
    strategy_name: str = ""
    strategy_sha: str = ""
    market_snapshot: dict = field(default_factory=dict)
    decision_inputs: dict = field(default_factory=dict)

    # Metadata
    created_at: datetime = field(default_factory=datetime.utcnow)


class Strategy(ABC):
    """
    Base class for strategy-as-code.

    Strategies are Python files with configurable class attributes.
    To create a variant: copy the file, rename, adjust parameters.

    Class Attributes:
        name: Unique strategy identifier
        version: Semantic version string

    Example:
        class MyStrategy(Strategy):
            name = "my_strategy"
            version = "1.0.0"

            # === PARAMETERS (edit directly) ===
            min_probability = 0.92
            max_hours_to_expiry = 72
            size_usd = 25

            def scan(self, markets: list[MarketData]) -> Iterator[Signal]:
                for m in markets:
                    if m.price >= self.min_probability:
                        yield Signal(...)
    """

    name: str = "base"
    version: str = "1.0.0"

    def __init__(self):
        """Initialize strategy with default logger."""
        self.logger = logging.getLogger(f"strategy.{self.name}")

    @classmethod
    def get_sha(cls) -> str:
        """
        Get SHA256 hash of strategy source code.

        Used for audit trail to track exact version of strategy
        that made each decision.

        Returns:
            First 12 characters of SHA256 hash, or "unknown" if unavailable
        """
        try:
            source = inspect.getsource(cls)
            return hashlib.sha256(source.encode()).hexdigest()[:12]
        except (OSError, TypeError):
            return "unknown"

    def get_params(self) -> dict:
        """
        Get configurable parameters from class attributes.

        Returns all non-private, non-callable class attributes
        except 'name' and 'version'.

        Returns:
            Dictionary of parameter name -> value
        """
        params = {}
        for key in dir(type(self)):
            if key.startswith('_'):
                continue
            if key in ('name', 'version', 'logger'):
                continue
            value = getattr(type(self), key, None)
            if callable(value):
                continue
            # Only include simple types
            if isinstance(value, (int, float, str, bool, list, dict)):
                params[key] = value
        return params

    @abstractmethod
    def scan(self, markets: list[MarketData]) -> Iterator[Signal]:
        """
        Scan markets and yield signals for opportunities.

        This is the main strategy logic. Iterate through markets,
        apply your criteria, and yield Signal objects for any
        opportunities found.

        Args:
            markets: List of MarketData objects to scan

        Yields:
            Signal objects for each opportunity
        """
        pass

    def filter(self, market: MarketData) -> bool:
        """
        Pre-filter markets before detailed analysis.

        Override to quickly exclude markets that don't meet
        basic criteria. Called before scan() for each market.

        Args:
            market: Market to check

        Returns:
            True if market should be analyzed, False to skip
        """
        return True

    def should_exit(self, position: Any, market: MarketData) -> Optional[Signal]:
        """
        Check if an existing position should be exited.

        Override to implement custom exit logic.

        Args:
            position: Current position (Position model)
            market: Current market data

        Returns:
            Signal to exit, or None to hold
        """
        return None

    def on_signal_executed(self, signal: Signal, result: Any):
        """Called when a signal is executed."""
        pass

    def on_position_closed(self, position: Any, pnl: float):
        """Called when a position is closed."""
        pass

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} name={self.name} v{self.version} sha={self.get_sha()}>"
