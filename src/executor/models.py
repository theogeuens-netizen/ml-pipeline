"""
SQLAlchemy models for the Polymarket Executor.

Tables:
- signals: Trading signals generated by strategies
- executor_orders: Orders placed (paper or live)
- positions: Open and closed positions
- executor_trades: Individual fills/trades
- strategy_states: Strategy runtime state and statistics
"""

from datetime import datetime
from enum import Enum
from typing import Optional

from sqlalchemy import (
    BigInteger,
    Boolean,
    DateTime,
    Enum as SQLEnum,
    Float,
    ForeignKey,
    Integer,
    Numeric,
    SmallInteger,
    String,
    Text,
    func,
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship

from src.db.models import Base, Market


class SignalStatus(str, Enum):
    """Signal lifecycle status."""
    PENDING = "pending"      # Awaiting risk check
    APPROVED = "approved"    # Passed risk check, ready for execution
    REJECTED = "rejected"    # Failed risk check
    EXECUTED = "executed"    # Order placed
    EXPIRED = "expired"      # Signal timed out
    CANCELLED = "cancelled"  # Manually cancelled


class OrderStatus(str, Enum):
    """Order lifecycle status."""
    PENDING = "pending"      # Submitted, awaiting fill
    PARTIAL = "partial"      # Partially filled
    FILLED = "filled"        # Fully filled
    CANCELLED = "cancelled"  # Cancelled before fill
    FAILED = "failed"        # Submission failed
    EXPIRED = "expired"      # Order expired


class PositionStatus(str, Enum):
    """Position lifecycle status."""
    OPEN = "open"            # Active position
    CLOSED = "closed"        # Position closed
    HEDGED = "hedged"        # Position is hedged (volatility strategy)
    EXPIRED = "expired"      # Market expired/resolved


class Signal(Base):
    """
    Trading signal generated by a strategy.

    Signals are evaluated by risk management before execution.
    """
    __tablename__ = "signals"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), index=True
    )

    # Source
    strategy_name: Mapped[str] = mapped_column(String(50), index=True)
    market_id: Mapped[int] = mapped_column(ForeignKey("markets.id"), index=True)

    # Signal details
    token_id: Mapped[str] = mapped_column(String(100))
    side: Mapped[str] = mapped_column(String(4))  # BUY or SELL
    reason: Mapped[str] = mapped_column(Text)
    edge: Mapped[Optional[float]] = mapped_column(Numeric(10, 6))  # Estimated edge
    confidence: Mapped[Optional[float]] = mapped_column(Numeric(10, 6))  # Confidence 0-1

    # Market state at signal time
    price_at_signal: Mapped[float] = mapped_column(Numeric(10, 6))
    best_bid: Mapped[Optional[float]] = mapped_column(Numeric(10, 6))
    best_ask: Mapped[Optional[float]] = mapped_column(Numeric(10, 6))

    # Sizing (filled by position sizer)
    suggested_size_usd: Mapped[Optional[float]] = mapped_column(Numeric(20, 2))

    # Status tracking
    status: Mapped[str] = mapped_column(
        String(20), default=SignalStatus.PENDING.value, index=True
    )
    status_reason: Mapped[Optional[str]] = mapped_column(Text)
    processed_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))

    # Relationships
    market: Mapped["Market"] = relationship()
    order: Mapped[Optional["ExecutorOrder"]] = relationship(back_populates="signal")


class ExecutorOrder(Base):
    """
    Order placed by the executor (paper or live).

    Tracks order lifecycle from submission to fill.
    """
    __tablename__ = "executor_orders"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), index=True
    )

    # Link to signal
    signal_id: Mapped[int] = mapped_column(ForeignKey("signals.id"), index=True)

    # Order details
    is_paper: Mapped[bool] = mapped_column(Boolean, default=True)
    token_id: Mapped[str] = mapped_column(String(100))
    side: Mapped[str] = mapped_column(String(4))  # BUY or SELL
    order_type: Mapped[str] = mapped_column(String(20))  # market, limit, spread

    # Pricing
    limit_price: Mapped[Optional[float]] = mapped_column(Numeric(10, 6))
    executed_price: Mapped[Optional[float]] = mapped_column(Numeric(10, 6))

    # Size
    size_usd: Mapped[float] = mapped_column(Numeric(20, 2))
    size_shares: Mapped[Optional[float]] = mapped_column(Numeric(20, 6))
    filled_shares: Mapped[float] = mapped_column(Numeric(20, 6), default=0)

    # External tracking (for live orders)
    polymarket_order_id: Mapped[Optional[str]] = mapped_column(String(100))

    # Status
    status: Mapped[str] = mapped_column(
        String(20), default=OrderStatus.PENDING.value, index=True
    )
    status_message: Mapped[Optional[str]] = mapped_column(Text)
    submitted_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    filled_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    cancelled_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))

    # Relationships
    signal: Mapped["Signal"] = relationship(back_populates="order")
    position: Mapped[Optional["Position"]] = relationship(back_populates="entry_order")
    trades: Mapped[list["ExecutorTrade"]] = relationship(back_populates="order")


class Position(Base):
    """
    Open or closed position.

    Tracks P&L and links to the volatility hedge strategy.
    """
    __tablename__ = "positions"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), index=True
    )

    # Source
    is_paper: Mapped[bool] = mapped_column(Boolean, default=True)
    strategy_name: Mapped[str] = mapped_column(String(50), index=True)
    market_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("markets.id"), index=True, nullable=True
    )  # Nullable for imported positions from unknown markets

    # Position details
    token_id: Mapped[str] = mapped_column(String(100))
    side: Mapped[str] = mapped_column(String(4))  # BUY or SELL (which side we hold)

    # Entry
    entry_order_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("executor_orders.id"), nullable=True
    )  # Nullable for imported positions
    entry_price: Mapped[float] = mapped_column(Numeric(10, 6))
    entry_time: Mapped[datetime] = mapped_column(DateTime(timezone=True))

    # Size
    size_shares: Mapped[float] = mapped_column(Numeric(20, 6))
    cost_basis: Mapped[float] = mapped_column(Numeric(20, 2))  # Total USD paid

    # Current state
    current_price: Mapped[Optional[float]] = mapped_column(Numeric(10, 6))
    current_value: Mapped[Optional[float]] = mapped_column(Numeric(20, 2))
    unrealized_pnl: Mapped[float] = mapped_column(Numeric(20, 2), default=0)
    unrealized_pnl_pct: Mapped[float] = mapped_column(Numeric(10, 6), default=0)

    # Exit (when closed)
    exit_price: Mapped[Optional[float]] = mapped_column(Numeric(10, 6))
    exit_time: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    realized_pnl: Mapped[float] = mapped_column(Numeric(20, 2), default=0)

    # Hedge tracking (for volatility strategy)
    hedge_position_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("positions.id"), nullable=True
    )
    is_hedge: Mapped[bool] = mapped_column(Boolean, default=False)

    # Status
    status: Mapped[str] = mapped_column(
        String(20), default=PositionStatus.OPEN.value, index=True
    )
    close_reason: Mapped[Optional[str]] = mapped_column(String(50))

    # Timestamps
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
    )

    # Relationships
    market: Mapped[Optional["Market"]] = relationship()
    entry_order: Mapped[Optional["ExecutorOrder"]] = relationship(back_populates="position")
    hedge_position: Mapped[Optional["Position"]] = relationship(
        remote_side="Position.id", foreign_keys=[hedge_position_id]
    )
    trades: Mapped[list["ExecutorTrade"]] = relationship(back_populates="position")


class ExecutorTrade(Base):
    """
    Individual fill/trade for an order.

    An order can have multiple trades (partial fills).
    """
    __tablename__ = "executor_trades"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    timestamp: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), index=True
    )

    # Links
    order_id: Mapped[int] = mapped_column(ForeignKey("executor_orders.id"), index=True)
    position_id: Mapped[Optional[int]] = mapped_column(
        ForeignKey("positions.id"), index=True
    )

    # Trade details
    is_paper: Mapped[bool] = mapped_column(Boolean, default=True)
    price: Mapped[float] = mapped_column(Numeric(10, 6))
    size_shares: Mapped[float] = mapped_column(Numeric(20, 6))
    size_usd: Mapped[float] = mapped_column(Numeric(20, 2))
    side: Mapped[str] = mapped_column(String(4))

    # Fees
    fee_usd: Mapped[float] = mapped_column(Numeric(20, 6), default=0)

    # External tracking
    polymarket_trade_id: Mapped[Optional[str]] = mapped_column(String(100))

    # Relationships
    order: Mapped["ExecutorOrder"] = relationship(back_populates="trades")
    position: Mapped[Optional["Position"]] = relationship(back_populates="trades")


class StrategyState(Base):
    """
    Runtime state and statistics for each strategy.

    Persists across restarts.
    """
    __tablename__ = "strategy_states"

    id: Mapped[int] = mapped_column(primary_key=True)
    strategy_name: Mapped[str] = mapped_column(String(50), unique=True, index=True)

    # Configuration snapshot
    config_json: Mapped[dict] = mapped_column(JSONB, default=dict)
    enabled: Mapped[bool] = mapped_column(Boolean, default=False)

    # Runtime state
    last_scan_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True))
    markets_scanned: Mapped[int] = mapped_column(Integer, default=0)

    # Statistics
    total_signals: Mapped[int] = mapped_column(Integer, default=0)
    total_trades: Mapped[int] = mapped_column(Integer, default=0)
    winning_trades: Mapped[int] = mapped_column(Integer, default=0)
    losing_trades: Mapped[int] = mapped_column(Integer, default=0)
    total_pnl: Mapped[float] = mapped_column(Numeric(20, 2), default=0)
    best_trade_pnl: Mapped[float] = mapped_column(Numeric(20, 2), default=0)
    worst_trade_pnl: Mapped[float] = mapped_column(Numeric(20, 2), default=0)

    # Detailed stats (JSON for flexibility)
    stats_json: Mapped[dict] = mapped_column(JSONB, default=dict)

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
    )


class PaperBalance(Base):
    """
    Paper trading balance tracking.

    Separate table to isolate paper state.
    """
    __tablename__ = "paper_balances"

    id: Mapped[int] = mapped_column(primary_key=True)
    balance_usd: Mapped[float] = mapped_column(Numeric(20, 2), default=10000.0)
    starting_balance_usd: Mapped[float] = mapped_column(Numeric(20, 2), default=10000.0)
    high_water_mark: Mapped[float] = mapped_column(Numeric(20, 2), default=10000.0)
    low_water_mark: Mapped[float] = mapped_column(Numeric(20, 2), default=10000.0)
    total_pnl: Mapped[float] = mapped_column(Numeric(20, 2), default=0)

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
    )
