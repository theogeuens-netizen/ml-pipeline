"""
Base Strategy interface.

All trading strategies must implement this interface.
Strategies yield signals, and the framework handles sizing, risk checks, and execution.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Iterator, Optional
import logging


class Side(str, Enum):
    """Trading side."""
    BUY = "BUY"
    SELL = "SELL"


@dataclass
class MarketData:
    """
    Market data passed to strategies for scanning.

    Contains current state and metadata from the markets table.
    """
    # Identifiers
    id: int
    condition_id: str
    question: str

    # Token IDs for trading
    yes_token_id: Optional[str]
    no_token_id: Optional[str]

    # Current prices
    price: float  # YES price (0-1)
    best_bid: Optional[float] = None
    best_ask: Optional[float] = None
    spread: Optional[float] = None

    # Time context
    hours_to_close: Optional[float] = None
    end_date: Optional[datetime] = None

    # Volume and liquidity
    volume_24h: Optional[float] = None
    liquidity: Optional[float] = None

    # Categories and metadata
    category: Optional[str] = None
    category_l1: Optional[str] = None  # e.g., CRYPTO, SPORTS, POLITICS
    category_l2: Optional[str] = None  # e.g., Bitcoin, NFL, US Elections
    category_l3: Optional[str] = None  # e.g., Price, Super Bowl, Presidential
    event_id: Optional[str] = None
    event_title: Optional[str] = None

    # Price history (optional, for mean reversion etc.)
    price_history: list[float] = field(default_factory=list)

    # Raw data for custom access
    raw: dict = field(default_factory=dict)


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Contains all information needed for the executor to place an order.
    """
    # What to trade
    token_id: str
    side: Side

    # Why (for logging and UI)
    reason: str

    # Signal quality metrics
    edge: float = 0.0  # Estimated edge (0-1)
    confidence: float = 0.5  # Confidence in the signal (0-1)

    # Market context at signal time
    market_id: int = 0
    price_at_signal: float = 0.0
    best_bid: Optional[float] = None
    best_ask: Optional[float] = None

    # Optional sizing hint (framework may override)
    suggested_size_usd: Optional[float] = None

    # Metadata
    strategy_name: str = ""
    created_at: datetime = field(default_factory=datetime.utcnow)
    metadata: dict = field(default_factory=dict)


class Strategy(ABC):
    """
    Base class for trading strategies.

    Implement `scan()` to yield signals for opportunities.
    The framework handles sizing, risk checks, and execution.
    """

    # Strategy metadata (override in subclass)
    name: str = "base"
    description: str = "Base strategy"
    version: str = "1.0.0"

    def __init__(self):
        """Initialize strategy with default logger."""
        self.logger = logging.getLogger(f"strategy.{self.name}")
        self.config: dict = {}

    def configure(self, config: dict):
        """
        Configure the strategy with parameters.

        Called by the framework when loading strategies.

        Args:
            config: Strategy-specific configuration dictionary
        """
        self.config = config
        self.logger.info(f"Configured {self.name} with: {config}")

    def get_param(self, key: str, default: Any = None) -> Any:
        """
        Get a configuration parameter.

        Args:
            key: Parameter name
            default: Default value if not configured

        Returns:
            Parameter value
        """
        return self.config.get(key, default)

    @abstractmethod
    def scan(self, markets: list[MarketData]) -> Iterator[Signal]:
        """
        Scan markets and yield signals for opportunities.

        This is the main strategy logic. Iterate through markets,
        apply your criteria, and yield Signal objects for any
        opportunities found.

        Args:
            markets: List of MarketData objects to scan

        Yields:
            Signal objects for each opportunity
        """
        pass

    def filter(self, market: MarketData) -> bool:
        """
        Pre-filter markets before detailed analysis.

        Override to quickly exclude markets that don't meet
        basic criteria. Called before scan() for each market.

        Args:
            market: Market to check

        Returns:
            True if market should be analyzed, False to skip
        """
        return True

    def should_exit(self, position: Any, market: MarketData) -> Optional[Signal]:
        """
        Check if an existing position should be exited.

        Override to implement custom exit logic. Called for each
        open position during the scan cycle.

        Args:
            position: Current position (Position model)
            market: Current market data

        Returns:
            Signal to exit, or None to hold
        """
        return None

    def on_signal_executed(self, signal: Signal, result: Any):
        """
        Called when a signal is executed.

        Override to track state or update strategy logic.

        Args:
            signal: The executed signal
            result: Execution result
        """
        pass

    def on_position_closed(self, position: Any, pnl: float):
        """
        Called when a position is closed.

        Override to track statistics or update strategy logic.

        Args:
            position: The closed position
            pnl: Realized P&L
        """
        pass

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} name={self.name} v{self.version}>"
