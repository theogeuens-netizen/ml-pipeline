"""
Streaming signal dataclass.

Represents a trading signal generated by the streaming strategy.
"""

from dataclasses import dataclass, field
from datetime import datetime, timezone


@dataclass
class StreamingSignal:
    """
    Signal generated by streaming book imbalance strategy.

    Contains all information needed for execution and audit trail.
    """

    # Core identifiers
    strategy_name: str
    market_id: int
    token_id: str
    condition_id: str

    # Direction
    side: str  # "BUY" (we only buy, never sell in this strategy)
    token_side: str  # "YES" or "NO" depending on imbalance direction

    # Pricing at signal time
    price_at_signal: float  # Execution price (ask for YES, 1-bid for NO)
    best_bid: float
    best_ask: float
    imbalance: float  # Book imbalance that triggered signal
    spread: float

    # Timing
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    hours_to_close: float = 0.0

    # Sizing
    size_usd: float = 1.1

    # Metadata
    reason: str = ""
    edge: float = 0.0
    confidence: float = 0.6
    market_question: str = ""

    @property
    def age_seconds(self) -> float:
        """Get signal age in seconds."""
        now = datetime.now(timezone.utc)
        created = self.created_at
        if created.tzinfo is None:
            created = created.replace(tzinfo=timezone.utc)
        return (now - created).total_seconds()

    @property
    def mid_price(self) -> float:
        """Calculate mid price from bid/ask."""
        return (self.best_bid + self.best_ask) / 2

    def to_dict(self) -> dict:
        """Convert to dictionary for logging/serialization."""
        return {
            "strategy_name": self.strategy_name,
            "market_id": self.market_id,
            "token_id": self.token_id,
            "condition_id": self.condition_id,
            "side": self.side,
            "token_side": self.token_side,
            "price_at_signal": self.price_at_signal,
            "best_bid": self.best_bid,
            "best_ask": self.best_ask,
            "imbalance": self.imbalance,
            "spread": self.spread,
            "created_at": self.created_at.isoformat(),
            "hours_to_close": self.hours_to_close,
            "size_usd": self.size_usd,
            "reason": self.reason,
            "edge": self.edge,
            "confidence": self.confidence,
        }
